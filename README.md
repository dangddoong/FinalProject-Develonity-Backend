# Develonity
> `Developer` + `Community` = `Develonity` 
- **입문 & 주니어 & 시니어 개발자 모두에게 가치 있는 커뮤니티를 만들고자 했습니다.**
- Q&A 게시판 활동(답변)을 통해 `Gift Point` 를 쌓고, 포인트로 `Gift Card` 를 살 수 있습니다.
- [미구현] Q&A 게시판 활동(답변)을 통해 단순히 `Gift Point` 뿐만 아니라 `Respect Point` 가 쌓이게 되고, `Respect Point` 를 기반으로 `외주, 과외 등의 서비스` 를 제공하고자 했습니다.

![브로셔메인페이지](https://user-images.githubusercontent.com/116135174/224562613-25b15240-4157-4a6c-a908-69a7a942bf95.PNG)

팀원 소개 👨‍👩‍👧‍👦
---



| [조성현](https://github.com/dangddoong) | [이솔](https://github.com/LEESOLL) | [김태웅](https://github.com/ultramancode) | [배지호](https://github.com/2Luda) | [송성원](https://github.com/SungWonSong) |
| --- | --- | --- | --- | --- |
| 1 | 2 | 3 | 4 | 5 |
| 6 | 7 | 8 | 9 | 10 |
| 11 | 12 | 13 | 14 | 15 | 




서비스 아키텍쳐📖
---

![서비스아키텍처](https://user-images.githubusercontent.com/116135174/224563517-e0caea58-799d-481c-958c-0c505306c922.png)


기술 스택 💻
---
Front-End 

![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f48544d4c2d4533344632363f7374796c653d666c6174266c6f676f3d68746d6c35266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224563690-49f7978a-08cc-444e-b68d-25f8f3dca096.svg)
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4353532d3135373242363f7374796c653d666c6174266c6f676f3d63737333266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224563708-a893b2d2-3a9f-437c-90f9-2fb1e4b5d59c.svg)
<img src="https://img.shields.io/badge/Visual Studio-5C2D91?style=flat&logo=Visual Studio&logoColor=white">
<img src="https://img.shields.io/badge/jQuery-0769AD?style=flat&logo=jQuery&logoColor=white">
<img src="https://img.shields.io/badge/JavaScript-F7DF1E?style=flat&logo=JavaScript&logoColor=white">

Back-End 

![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4a6176612d3030373339363f7374796c653d666c6174266c6f676f3d4f70656e4a444b266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224563807-67c19880-4cf0-4dff-864e-8c0b5e334d26.svg)
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f537072696e675f426f6f742d3644423333463f7374796c653d666c6174266c6f676f3d737072696e67626f6f74266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224563810-e6bf9887-21e0-4335-b363-4a06d47ff332.svg)
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f537072696e672d3644423333463f7374796c653d666c6174266c6f676f3d537072696e67266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224563819-60e7b43b-41d8-48c4-9ff5-8d920274f05e.svg)
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f537072696e675f446174615f4a50412d3644423333463f7374796c653d666c6174](https://user-images.githubusercontent.com/116135174/224563822-34f5705d-1a3a-40c2-92cb-53476f64019f.svg)
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f537072696e675f53656375726974792d3644423333463f7374796c653d666c6174266c6f676f3d737072696e677365637572697479266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224563832-48210ac1-d1a8-4712-8f58-d2bbeab82e0a.svg)
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f52656469732d4443333832443f7374796c653d666c6174266c6f676f3d7265646973266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224563838-7056f1cc-45dd-4468-8f62-a28f93c0bc7c.svg)
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f517565727944736c2d3430414546303f7374796c653d666c6174](https://user-images.githubusercontent.com/116135174/224563844-c776b411-7082-4d18-ac10-16f81ebffbe9.svg)
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4a57542d4139323235433f7374796c653d666c6174](https://user-images.githubusercontent.com/116135174/224563850-b63732e7-71f6-4f82-89d5-f8bddc791feb.svg)
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f477261646c652d3032333033413f7374796c653d666c6174266c6f676f3d677261646c65266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224563860-f3344686-f5e5-472a-88d1-2f47a136a82a.svg)
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f48696265726e6174652d3539363636433f7374796c653d666c6174266c6f676f3d48696265726e617465266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224563866-331e0ce4-ee26-444c-9660-89ca9d191dab.svg)
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f506f73746d616e2d4646364333373f7374796c653d666c6174266c6f676f3d506f73746d616e266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224563871-9ccb51f3-1be2-45d0-ab1f-e4d792e049dd.svg)
<img src="https://img.shields.io/badge/JUnit5-25A162?style=flat&logo=JUnit5&logoColor=white">
<img src="https://img.shields.io/badge/MySQL-4479A1?style=flat&logo=MySQL&logoColor=white">

Server 

![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f416d617a6f6e5f53332d3536394133313f7374796c653d666c6174266c6f676f3d616d617a6f6e7333266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224563965-0407b444-b4dc-4fcd-8060-5c0cac870f57.svg)
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f416d617a6f6e5f4543322d4646393930303f7374796c653d666c6174266c6f676f3d616d617a6f6e656332266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224563977-98fc9d8d-1820-4881-aa81-e593585c570f.svg)
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f416d617a6f6e5f5244532d3532374646463f7374796c653d666c6174266c6f676f3d616d617a6f6e726473266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224565820-02995aae-65b8-4bdb-ad84-06500f32741d.svg)


Etc ⛓️

![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4769746875622d3138313731373f7374796c653d666c6174266c6f676f3d676974687562266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224564009-4100e123-0818-44f8-acba-bc5d0540d66c.svg)
<img src="https://img.shields.io/badge/GitHub Actions-2088FF?style=flat&logo=GitHub Actions&logoColor=white">
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f536c61636b2d3441313534423f7374796c653d666c6174266c6f676f3d736c61636b266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224564017-f1c15951-64d8-4352-866a-12ca984e6424.svg)
![68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4e6f74696f6e2d3030303030303f7374796c653d666c6174266c6f676f3d6e6f74696f6e266c6f676f436f6c6f723d7768697465](https://user-images.githubusercontent.com/116135174/224564022-db759b69-a20d-4ec6-9bdb-7fa96bf36d69.svg)
<img src="https://img.shields.io/badge/Jira-0052CC?style=flat&logo=Jira&logoColor=white">

기술적 의사결정 📋
---
<details>
<summary>Session vs Token(JWT)</summary>
<br>

- 보안 vs 효율&확장성
- 서비스의 특성상(커뮤니티) 보안적으로 매우 민감한 주제는 아니라고 판단<br>
- HTTP의 비상태성(Stateless)를 그대로 활용할 수 있고, 따라서 높은 확장성을 가질 수 있는 Token방식을 채택

<br>

>**문제점** <br>
>- 보안 이슈 발생
><br>

>**해결책**
>- refresh token을 도입하여 access token의 유효기간을 짧게 가져감
>- RTR(refresh token rotation)을 도입하여 refresh token 탈취 시 문제점 완
>- 계정정보 or 회원탈퇴 등 중요한 기능들은 ‘비밀번호 검증＇을 1회 더 하는 방식으로 보안 강화

<details><summary>➕access token과 refresh token이 모두 탈취 당했을 경우에 대한 고민🤷</summary>
<br>

📋 참고자료
- [네이버 토큰 갱신 방법[grant_type, client id를 같이 보내는 방식]](https://developers.naver.com/docs/login/devguide/devguide.md#5-1-2-%EA%B0%B1%EC%8B%A0-%ED%86%A0%ED%81%B0%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC:~:text=Authorization%3A%20Bearer%20ACCESS_TOKEN-,5.1.2%20%EA%B0%B1%EC%8B%A0%20%ED%86%A0%ED%81%B0%EC%97%90%20%EB%8C%80%ED%95%98%EC%97%AC,-%EC%A0%91%EA%B7%BC%20%ED%86%A0%ED%81%B0%EC%9D%80%20%EC%A0%91%EA%B7%BC)

- [카카오 토큰 갱신 방법](https://developers.kakao.com/docs/latest/ko/kakaologin/rest-api#refresh-%20%20%20%20%20%20%20%20%20token:~:text=%3A1234%0A%7D-,%ED%86%A0%ED%81%B0%20%EA%B0%B1%EC%8B%A0%ED%95%98%EA%B8%B0,-%EA%B8%B0%EB%B3%B8%20%EC%A0%95%EB%B3%B4)

<br>

**📌 현재 프로젝트에서 대응 가능한 방법들**<br>
- 사용자가 서비스를 지속적으로 이용중인 상황<br>
   - RTR(refresh token rotation)을 적용하고 access token의 유효시간을 30분으로 짧게 설정<br>
   - `[reissue 실패 → 재로그인 → 탈취된 refresh token 무효화]` 가능<br>
   
- 토큰이 지속적으로 탈취되는 상황
   - 해당 회원을 일단 `탈퇴처리`, 해커의 `나쁜 행동을 막고`, 
   - 개인적으로 네트워크와 컴퓨터를 리셋(포맷)한 이후 다시 `계정 복구`(soft delete 방식으로 회원 탈퇴 기능 구현)<br>
  
- 특정 상황이 발생하여 회원 다수의 token이 탈취된 경우
   - `30분여 서비스 점검 실시(access token 유효기간 만료를 위함) 및
    `redis(refresh token 저장소)를 재가동` 하는 방법 고려. (서비스 점검기간동안 보안적인 대처도 병행)<br>
   
- 현재 계정정보 접근, 회원탈퇴 등 민감한 서비스들에는 `패스워드 재검증 로직`을 포함하고 있으므로 `개인정보 유출, 금전적 피해` 가 발생 가능한 경우는 예방하고 있다.
</details>

</details><br>
<details>
<summary>Redis - Token 저장소로 Redis를 선정한 이유</summary><br><br>

>-  Key(LoginId)-Value(Refresh Token) 외의 다른 필드가 필요하지 않음
>-  I/O가 빈번하게 발생하는 환경
>- 저장된 데이터의 개수와 무관하게 `O(1)` 의 수행시간을 가짐
>- 저장된 모든 token을 조회하는 등의 싱글 스레드의 단점이 부각 될 상황이 없음
<br><br>
</details>

<details>
<summary>Admin과 User 분리</summary><br>


**기존 방식**

- 동일한 User Entity에서 `Role Enum` 으로 Admin과 User를 구분
- 동일한 security filter와  Authentication Service를 사용

>**문제점**
><br>
>- 근본적으로 User와 Admin의 생명주기가 다름
>- User와 Admin의 역할과 그에 따른 기능들이 다름
>- User와 Admin의 인증과정을 분리할 수 없음.
><br>

>**해결**
><br>
>- Entity 및 Package 분리
>- security filter와  Authentication Service 분리
>- Authentication Service에 `팩토리 패턴` 적용하여 OCP 원칙을 지키고자 노력
</details>

<details>
<summary>게시글 JPA 상속 관계 매핑(단일 테이블 전략)</summary><br>



>JPA는 테이터베이스와 객체를 매핑해주는 자바 진영의 ORM 기술 표준이지만 객체의 상속 관계와 정확하게 일치하는 데이터베이스 모델링은 존재하지 않음
>따라서 차선책으로 상속 관계와 비교적 유사한 **슈퍼타입-서브타입** 모델링 기법으로 데이터베이스를 상속 객체에 매핑
>슈퍼타입-서브타입 논리모델을 실제 데이터베이스 물리모델로 구현하는 방법으로 3가지 전략 중 단일 테이블 전략을 사용

단일 테이블 전략의 **장점**

- 조인이 필요 없으므로 조회 성능이 빠름
- 조회 쿼리가 단순

단일 테이블의 **단점**

- 하위 엔티티의 필드값은 모두 Null을 허용
- 하나의 테이블에 칼럼이 많아져 복잡

단점이 있음에도 **단일 테이블 전략을** **선택한 이유**

- 현재 게시글의 필드값을 최대한 적게 가져가는 방식을 사용 중, 테이블 칼럼 수가 적기 때문에 단일 테이블 전략을 사용하더라도 복잡해지지 않음
- 비록 데이터베이스에는 Null값을 허용하더라도 실제 객체가 Null값을 가지고 있는 것은 아님

>만약 단일 테이블 전략이 아니라 각자 테이블을 가지는 조인 전략과 같은 방식을 사용했다면 Null값은 들어가지 않지만 조회 쿼리가 복잡해지고 INSERT QUERY를 2번 실행해야 하기 때문에 
>단일 테이블 전략을 사용하기로 결정
</details>

<details>
<summary>id를 활용한 간접참조 방식 설계</summary><br>

- **직접 참조** : Entity 클래스를 설계할 때 @OneToOne, @OneToMany ... 와 같은 어노테이션을 써서 Entity 간에 연관 매핑하는 것
- **간접 참조** : 객체를 직접 참조하지 않고, 식별값을 이용하는 것

- **직접 참조 방식의 단점**
- 의존 관계 형성
- 편한 탐색 오용 방지
- 직접 참조를 한다면 연관 관계 맺은 객체를 편하게 탐색할 수 있고 바뀌길 원하지 않는 참조 객체의 값이 손쉽게 바뀔 가능성이 있다. 직접 참조는 편한만큼 위험한 것이다.
- 예를 들어 Board Entity안에 user라는 변수가 있다면 Board를 다룰 때 User를 변경할 수 있는 가능성과 여러 실수의 가능성이 존재하게 됨
- 즉 User 라는 Entity 자체를 날것으로 가져오게 되면, Entity 가 오염이 될 수 도 있음, setter 를 통해서든, 도메인 서비스를 통해서든 어떤 일이 벌어질 수 있는 가능성을 열어둔 것
- **결론**

User Entity도 안전하게 보호가 되고, Board Entity에만 집중할 수 있는 방법으로 **간접 참조** 방식을 ****이용하는 것이 나을 것이라고 판단했고,

간접 참조를 하면 의존 관계가 형성되지 않아서 추후 시스템을 확장할 때도 유리하기 때문에 

**간접 참조 방식을 이용해서 설계를 하게 됐다.**
</details>

<details>
<summary>이미지 서버로 AWS S3 사용하게 된 이유</summary><br>
- 저희가 사용한 커뮤니티 사이트나 SNS와 같이 서버에 많은 미디어 파일을 저장해야 하는 경우, EC2와 EBS만을 사용해서 저장을 하게 되면 용량에 따른 과금도 부담되고 (비용적인 문제, S3는 사용한 만큼만 비용 지불), 저장소를 구축해서 관리하는 것에도 문제가 있었습니다. (성능 문제)

하지만 S3를 사용하면 S3 한 곳에 모든 미디어 파일을 저장할 수 있고,  비용적인 문제도 EC2와 EBS만을 사용해서 구축하는 것보다 훨씬 저렴하고 ,구축 후 확장이나 축소와 같은 DB를 관리하는 것에도 속도를 유지하는 상태에서  저장소가 무한이라는 장점이 있어 사용하게 되었습니다.


S3 말고 EBS를 사용해보려 했으나 EBS를 선택하지 않은 이유는

- S3 보다 가격이 비쌉니다.
- 반드시 하나의 인스턴스에서만 접근 할 수 있습니다. (복수개의 Application이 하나의 EBS에 담겨있는 데이터에 동시에 접근하는 것이 불가능합니다.)
- 생성 전에 반드시 그 크기를 지정해주어야 합니다. 예를 들어 10G, 혹은 1T 등으로 정하는 경우, 다음과 같은 문제가 나갑니다.
- 신청한 용량 중, 쓰지 않는 부분에 불필요한 cost를 내야합니다.
- 쌓이는 데이터가 신청한 용량을 넘어서게 되는 경우, 대용량에 새로운 volume을 신청하여 데이터를 옮기고, 기존에 volume을 반납해야하는 번거로움이 생깁니다.

하지만 S3는 사용한 만큼만 비용을 지불하고, 무한대로 확장이 가능하며, EBS와는 다르게

여러개의 Application이 동시에 접근할 수 있다는 장점이 있으므로 S3을 선택하였습니다.

<img width="1000" alt="스크린샷_2023-03-10_오후_8 19 32" src="https://user-images.githubusercontent.com/116135174/224602116-94870db8-6d7b-42aa-8860-4e5620d2945a.png">
</details>
</details>

트러블 슈팅 📌
---
<details>
<summary>4조가 트러블 슈팅 or 성능개선을 하는 방식</summary>

1. 안건제시

2. 문제분석

3. 개선계획수립

4. 코드 수정

5. PR을 통해 검토

6. 반영
   - 실제 예시 링크([23.02.22 보드,코멘트 관련 비상회의록](https://www.notion.so/23-02-22-6ddb6bb392c841828c161472d9e86fb0))
</details>
<details>
<summary>CI - sub module & profile & embedded redis 기반의 배포, 테스트 환경 분리</summary><br>
</details>
<details>
<summary>Pre-signed URL 방식을 택한 이유</summary><br>

클라이언트에서 S3에 파일을 업로드 하는 방법으로는 크게 3가지가 있다.

**1. AWS SDK를 이용해 직접 업로드**

**2. API 서버에 파일을 전달하고 API 서버에서 S3에 업로드(기존 적용 방법)**

**3. PreSignedURL을 이용한 클라이언트 -> S3 업로드 방식(트러블 슈팅 후 적용 방법)**
![images_kyy00n_post_a50e0237-a9eb-4ab2-8be9-ae0d2a2ea5cf_image](https://user-images.githubusercontent.com/116135174/224603164-93553af3-e4ed-40be-8608-9cd43ee8b056.png)



1 번의 방법은 서버를 거치지 않지만, AWS SDK를 써서 S3이용이 가능해야 하기 때문에 브라우저에서 AWS SDK를 사용하는 시점에는<br> 
결국  AWS Access Key와 Secret Key 정보를 알고 있어야 한다. 

이는 Key 정보가 브라우저에서 노출될 수 있고 악성 해커가 이를 이용하면 S3 리소스를 탈취해 갈 수 있는 위험성이 있다.<br>

2번의 방법은 API서버에서 파일을 업로드하기 때문에 AWS Access Key와 Secret Key 정보를 서버가 가지고 있어 Key 정보가 노출되는 위험은 없다.<br> 
이때 파일을 업로드하면 파일 전달 흐름이 브라우저 -> 서버 -> S3 순으로 되게 되는데<br> 
이는 저장하지도 않을 파일들이 서버를 통해가면서 불필요한 서버의 리소스를 사용하게 된다.<br>
또한 과도한 업로드 작업이 생기면 서버에 과부하가 걸리게 되고 서버를 한 번 거쳐가는 지연시간이 생기게 된다.<br>

결국 위 두 가지 방법 모두 가능하지만 단점이 존재한다. 

(우리는 기존에 2번을 선택하여 프론트까지 구현하였다.)

위 방법들의 `단점을 보완`하기 위해 AWS에서는 S3에 객체를 업로드하고 다운로드하기 위한 방법으로<br> 
`Pre-signed URL 기능`을 지원하고 있고 이를 사용하여 성능을 개선하고자 결정하였다. 

![presigned url](https://user-images.githubusercontent.com/116135174/224603186-fc380104-5cf3-4b43-9541-df2b09a2770a.png)

하나의 파일을 S3에 업로드하기 위한 Pre-signed URL 과정은 다음과 같다.

>1.  클라이언트에서 서버에 pre-signed URL를 받기 위한 API 호출 (POST 요청)<br>
>2. 서버에서 AWS S3에 pre-signed URL요청 3. AWS에서 pre-signed URL을 서버에 반환<br>
>4. 서버는 반환받은 pre-signed URL를 클라이언트에 전달<br>
>5. 클라이언트에서 AWS pre-signed URL로 이미지 upload (S3에 직접 업로드) (PUT 요청)<br>
>6. 서버에게 해당 요청이 종료 되었음을 알림<br>

**서버의 역할이 파일 업로드를 처리하는 것에서 문자열을 주고받는 식으로 바뀌었기 때문에<br> 
프로세스가 훨씬 가벼워지고 브라우저에서 Key를 직접 만지지도 않아 보안성이 우수해졌다.**
</details>
<details>
<summary>QueryDSL</summary><br>

![기존검색방식](https://user-images.githubusercontent.com/116135174/224602932-fa25e3c5-067f-4135-aeee-fa01f4264fab.png)

위와 같이 `Spring Data Jpa`를 이용해서 조회 기능을 구현 하기에는 검색 조건 등 여러 부분에서 작동이 효율적으로 되지 않았고,

여러 조건의 검색 방식을 구현하기 위해서는 비슷한 메소드들을 추가로 작성 해줘야 해서 

**비효율적**이었습니다.

![수정방식](https://user-images.githubusercontent.com/116135174/224602950-0c88be12-a095-46d2-b477-00a294116478.png)
![화면_캡처_2023-03-10_191553](https://user-images.githubusercontent.com/116135174/224602959-1c019c2f-e8da-4412-b294-6fec64ba0b6f.png)

하지만 `QueryDSL`을 활용, **`동적 쿼리`**를 작성해서  편하게 구현이 가능해졌습니다.

# 동적 쿼리란 ?

동적 쿼리란 **상황에 따라 다른 문법의 SQL을 적용**하는 것을 말합니다.

예를 들면 DB에서 값을 조회할 때 조회 조건이 위와 같이 동적으로 바뀌어야 하는 경우가 많습니다. 이런 상황을 Querydsl을 사용해서 손쉽게 해결할 수 있었습니다.

`Querydsl`은 아래 2가지 기능을 제공합니다.

- `where()`에 `null`이 들어오면 무시한다.
- `where()`에 **`,**` 을 `and` 조건으로 사용한다.

**`BooleanExpression`**을 사용해서 `삼항 연산자`를 통해 위 기능을 활용 했고, 한개의 메소드로 여러 **검색 조건**을 활용할 수 있게 하였습니다.
</details>
</details>


